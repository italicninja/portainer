version: '3.8'

services:
  vercel-ddns:
    image: alpine:3.18
    container_name: vercel-ddns
    environment:
      # Vercel API Configuration
      VERCEL_TOKEN: ${VERCEL_TOKEN}
      VERCEL_DOMAIN: ${VERCEL_DOMAIN}
      VERCEL_RECORD_NAME: ${VERCEL_RECORD_NAME:-@}
      VERCEL_RECORD_TYPE: ${VERCEL_RECORD_TYPE:-A}
      
      # Check interval in seconds (300 = 5 minutes)
      CHECK_INTERVAL: ${CHECK_INTERVAL:-300}
      
      # Optional: Set timezone
      TZ: ${TZ:-UTC}
    volumes:
      - 'ddns_data:/app/data'
    working_dir: /app
    entrypoint: ["/bin/sh"]
    command:
      - -c
      - |
        echo "Installing dependencies..."
        apk add --no-cache curl jq

        echo "Creating DDNS script..."
        cat > /app/ddns.sh << 'SCRIPT_END'
        #!/bin/sh
        set -e

        DATA_DIR="/app/data"
        IP_FILE="$${DATA_DIR}/last_ip.txt"
        LOG_PREFIX="[$(date '+%Y-%m-%d %H:%M:%S')] VERCEL-DDNS:"

        mkdir -p "$${DATA_DIR}"

        log() {
            echo "$${LOG_PREFIX} $$1"
        }

        get_public_ip() {
            for service in "https://ipv4.icanhazip.com" "https://api.ipify.org" "https://checkip.amazonaws.com"; do
                if ip=$$(curl -s --max-time 10 "$${service}" | tr -d '\n\r'); then
                    if echo "$${ip}" | grep -E '^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$$' > /dev/null; then
                        echo "$${ip}"
                        return 0
                    fi
                fi
            done
            return 1
        }

        update_vercel_record() {
            local domain="$$1"
            local record_name="$$2"
            local record_type="$$3"
            local new_ip="$$4"

            response=$$(curl -s -H "Authorization: Bearer $${VERCEL_TOKEN}" \
                "https://api.vercel.com/v2/domains/$${domain}/records")

            record_id=$$(echo "$${response}" | jq -r ".records[] | select(.name == \"$${record_name}\" and .type == \"$${record_type}\") | .id" 2>/dev/null)

            if [ -n "$${record_id}" ] && [ "$${record_id}" != "null" ]; then
                log "Updating existing DNS record (ID: $${record_id})"
                update_response=$$(curl -s -X PATCH \
                    -H "Authorization: Bearer $${VERCEL_TOKEN}" \
                    -H "Content-Type: application/json" \
                    -d "{\"value\": \"$${new_ip}\"}" \
                    "https://api.vercel.com/v2/domains/$${domain}/records/$${record_id}")
            else
                log "Creating new DNS record"
                update_response=$$(curl -s -X POST \
                    -H "Authorization: Bearer $${VERCEL_TOKEN}" \
                    -H "Content-Type: application/json" \
                    -d "{\"name\": \"$${record_name}\", \"type\": \"$${record_type}\", \"value\": \"$${new_ip}\"}" \
                    "https://api.vercel.com/v2/domains/$${domain}/records")
            fi

            if echo "$${update_response}" | jq -e '.error' > /dev/null 2>&1; then
                error_message=$$(echo "$${update_response}" | jq -r '.error.message')
                log "ERROR: Failed to update DNS record: $${error_message}"
                return 1
            else
                log "Successfully updated DNS record: $${record_name}.$${domain} -> $${new_ip}"
                return 0
            fi
        }

        validate_config() {
            if [ -z "$${VERCEL_TOKEN}" ]; then
                log "ERROR: VERCEL_TOKEN environment variable is required"
                exit 1
            fi

            if [ -z "$${VERCEL_DOMAIN}" ]; then
                log "ERROR: VERCEL_DOMAIN environment variable is required"
                exit 1
            fi

            log "Configuration validated successfully"
            log "Domain: $${VERCEL_DOMAIN}"
            log "Record: $${VERCEL_RECORD_NAME}.$${VERCEL_DOMAIN} ($${VERCEL_RECORD_TYPE})"
            log "Check interval: $${CHECK_INTERVAL} seconds"
        }

        main() {
            log "Starting Vercel Dynamic DNS service"

            validate_config

            while true; do
                log "Checking current public IP..."

                if ! current_ip=$$(get_public_ip); then
                    log "ERROR: Failed to get public IP address"
                    sleep "$${CHECK_INTERVAL}"
                    continue
                fi

                log "Current public IP: $${current_ip}"

                last_ip=""
                if [ -f "$${IP_FILE}" ]; then
                    last_ip=$$(cat "$${IP_FILE}" 2>/dev/null || echo "")
                fi

                if [ "$${current_ip}" != "$${last_ip}" ]; then
                    log "IP address changed from '$${last_ip}' to '$${current_ip}'"

                    if update_vercel_record "$${VERCEL_DOMAIN}" "$${VERCEL_RECORD_NAME}" "$${VERCEL_RECORD_TYPE}" "$${current_ip}"; then
                        echo "$${current_ip}" > "$${IP_FILE}"
                        log "DNS update completed successfully"
                    else
                        log "ERROR: Failed to update DNS record"
                    fi
                else
                    log "IP address unchanged ($${current_ip})"
                fi

                log "Sleeping for $${CHECK_INTERVAL} seconds..."
                sleep "$${CHECK_INTERVAL}"
            done
        }

        trap 'log "Received shutdown signal, exiting..."; exit 0' TERM INT
        main
        SCRIPT_END

        echo "Starting DDNS service..."
        chmod +x /app/ddns.sh
        exec /app/ddns.sh
    deploy:
      resources:
        limits:
          cpus: '0.1'
          memory: 64M
        reservations:
          cpus: '0.05'
          memory: 32M
    healthcheck:
      test: ["CMD", "pgrep", "-f", "ddns.sh"]
      interval: 60s
      timeout: 10s
      retries: 3
      start_period: 30s
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
    labels:
      - "com.docker.compose.project=networking"
      - "com.docker.compose.service=vercel-ddns"
    restart: unless-stopped
    networks:
      - ddns_network

networks:
  ddns_network:
    driver: bridge

volumes:
  ddns_data:
    driver: local